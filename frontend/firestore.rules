rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Admin: email in config/app adminEmails array, or custom claim admin=true
    function isAdmin() {
      return request.auth != null && (
        request.auth.token.admin == true ||
        exists(/databases/$(database)/documents/config/app) &&
        request.auth.token.email in get(/databases/$(database)/documents/config/app).data.get('adminEmails', [])
      );
    }

    // Users: read for vote; update/set vote counts; create allowed so first vote can create author doc
    match /users/{userId} {
      allow read: if request.auth != null;
      allow update: if request.auth != null &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['totalHelpfulVotes', 'totalNotHelpfulVotes']);
      allow create: if request.auth != null &&
        request.resource.data.keys().hasOnly(['totalHelpfulVotes', 'totalNotHelpfulVotes']);
      allow delete: if false;
    }

    match /forumPosts/{postId} {
      allow read: if true;
      allow create, update: if request.auth != null;
      allow delete: if request.auth != null && (resource.data.authorId == request.auth.uid || isAdmin());

      match /answers/{answerId} {
        allow read: if true;

        // CREATE Answer Rule
        allow create: if request.auth != null &&
                         request.resource.data.authorId == request.auth.uid &&
                         request.resource.data.content is string &&
                         request.resource.data.content.size() > 0 &&
                         request.resource.data.postId == postId &&
                         request.resource.data.helpfulVoteCount == 0 &&
                         request.resource.data.notHelpfulVoteCount == 0 &&
                         request.resource.data.keys().hasAll(['authorId', 'content', 'timestamp', 'postId', 'authorDisplayName', 'helpfulVoteCount', 'notHelpfulVoteCount']) &&
                         request.resource.data.keys().hasOnly(['authorId', 'content', 'timestamp', 'postId', 'authorDisplayName', 'helpfulVoteCount', 'notHelpfulVoteCount']);

        // UPDATE Answer Rule
        allow update: if request.auth != null &&
                         (request.resource.data.authorId == null || request.resource.data.authorId == resource.data.authorId) &&
                         (request.resource.data.postId == null || request.resource.data.postId == resource.data.postId) &&
                         (request.resource.data.timestamp == null || request.resource.data.timestamp == resource.data.timestamp) &&
                         (
                           ( // Case 1: Author updates
                             resource.data.authorId == request.auth.uid &&
                             (request.resource.data.content == null || (request.resource.data.content is string && request.resource.data.content.size() > 0)) &&
                             (request.resource.data.authorDisplayName == null || request.resource.data.authorDisplayName == resource.data.authorDisplayName) &&
                             (request.resource.data.lastEditedAt == null || request.resource.data.lastEditedAt == request.time) &&
                             (request.resource.data.helpfulVoteCount == null || request.resource.data.helpfulVoteCount == resource.data.helpfulVoteCount) &&
                             (request.resource.data.notHelpfulVoteCount == null || request.resource.data.notHelpfulVoteCount == resource.data.notHelpfulVoteCount) &&
                             request.resource.data.keys().hasOnly(['authorId', 'content', 'timestamp', 'postId', 'authorDisplayName', 'helpfulVoteCount', 'notHelpfulVoteCount', 'lastEditedAt'])
                           ) ||
                           ( // Case 2: Vote count update
                             (request.resource.data.content == null || request.resource.data.content == resource.data.content) &&
                             (request.resource.data.authorDisplayName == null || request.resource.data.authorDisplayName == resource.data.authorDisplayName) &&
                             (
                               request.resource.data.diff(resource.data).affectedKeys().hasOnly(['helpfulVoteCount', 'notHelpfulVoteCount']) ||
                               request.resource.data.diff(resource.data).affectedKeys().hasOnly(['helpfulVoteCount']) ||
                               request.resource.data.diff(resource.data).affectedKeys().hasOnly(['notHelpfulVoteCount'])
                             )
                           )
                         );

        allow delete: if request.auth != null &&
                         (resource.data.authorId == request.auth.uid || isAdmin());
      }
    }

    // Rules for userItemVotes collection
    match /userItemVotes/{voteDocId} {
      // Allow reading if the user ID in the document ID prefix matches the authenticated user
      // This allows checking for non-existent votes without permission errors
      allow read: if request.auth != null && 
                     voteDocId.split('_')[0] == request.auth.uid;

      allow create: if request.auth != null &&
                       // Corrected to use split():
                       (voteDocId.split('_')[0] == request.auth.uid && voteDocId.split('_').size() >= 2) &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.itemId is string &&
                       request.resource.data.itemType in ['post', 'answer'] &&
                       request.resource.data.voteType in ['helpful', 'notHelpful'] &&
                       request.resource.data.timestamp != null &&
                       request.resource.data.keys().hasAll(['userId', 'itemId', 'itemType', 'voteType', 'timestamp']) &&
                       (request.resource.data.keys().hasOnly(['userId', 'itemId', 'itemType', 'voteType', 'timestamp']) ||
                        request.resource.data.keys().hasOnly(['userId', 'itemId', 'itemType', 'voteType', 'timestamp', 'postId']));

      allow update: if request.auth != null &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.itemId == resource.data.itemId &&
                       request.resource.data.itemType == resource.data.itemType &&
                       request.resource.data.voteType in ['helpful', 'notHelpful'] &&
                       request.resource.data.timestamp != null &&
                       (request.resource.data.keys().hasOnly(['userId', 'itemId', 'itemType', 'voteType', 'timestamp']) ||
                        request.resource.data.keys().hasOnly(['userId', 'itemId', 'itemType', 'voteType', 'timestamp', 'postId']));

      allow delete: if request.auth != null &&
                       resource.data.userId == request.auth.uid;
    }

    // Config: admin emails list (read by logged-in users for UI; write via Console only)
    match /config/app {
      allow read: if request.auth != null;
      allow write: if false;
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}